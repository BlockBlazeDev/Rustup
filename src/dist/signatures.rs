//! Signature verification support for Rustup.

// TODO: Determine whether we want external keyring support

use std::io::Read;

use anyhow::Result;

use sequoia_openpgp::{
    parse::{stream::*, Parse},
    policy::{HashAlgoSecurity, StandardPolicy},
    types::HashAlgorithm,
    Cert, KeyHandle,
};

use crate::config::PgpPublicKey;

pub(crate) fn sequoia_policy() -> StandardPolicy<'static> {
    let mut policy = StandardPolicy::new();

    // The builtin Rust signature key uses SHA-1 for its own signature, even though the individual
    // signatures generated by it nowadays use SHA-512. Sequoia added a cutoff date for SHA1,
    // 2023-02-01, which caused warnings to be displayed to rustup users from that day onwards.
    //
    // To keep supporting the Rust signature key, we allow the SHA-1 algorithm in rustup without a
    // cutoff date when verifying the signature key bindings. SHA-1 data signatures are still
    // disallowed.
    policy.reject_hash_property_at(
        HashAlgorithm::SHA1,
        HashAlgoSecurity::SecondPreImageResistance,
        None,
    );

    policy
}

/// Returns the index of the cert in `certs` that verifies a
/// signature.
///
/// Ignores any signatures that are bad for any reason.  If no
/// signature could be verified, returns `None`.
// XXX: This is a bit of an odd policy.  Shouldn't we fail if we
// encounter a single bad signature (bad as in checksum doesn't check
// out, not bad as in we don't have the key)?
pub(crate) fn verify_signature<T: Read + Send + Sync>(
    content: T,
    signature: &str,
    certs: &[PgpPublicKey],
) -> Result<Option<usize>> {
    let p = sequoia_policy();

    let helper = Helper::new(certs);
    let mut v = DetachedVerifierBuilder::from_reader(signature.as_bytes())?
        .with_policy(&p, None, helper)?;
    v.verify_reader(content)?;
    Ok(v.into_helper().index)
}

struct Helper<'a> {
    certs: &'a [PgpPublicKey],
    // The index of the cert in certs that successfully verified a
    // signature.
    index: Option<usize>,
}

impl<'a> Helper<'a> {
    fn new(certs: &'a [PgpPublicKey]) -> Self {
        Helper { certs, index: None }
    }
}

impl VerificationHelper for Helper<'_> {
    fn get_certs(&mut self, _: &[KeyHandle]) -> anyhow::Result<Vec<Cert>> {
        Ok(self.certs.iter().map(|c| c.cert().clone()).collect())
    }

    fn check(&mut self, structure: MessageStructure<'_>) -> anyhow::Result<()> {
        for layer in structure.into_iter() {
            match layer {
                MessageLayer::SignatureGroup { results } => {
                    // We ignore any errors for now.
                    for GoodChecksum { ka, .. } in results.into_iter().flatten() {
                        // A good signature!  Find the index
                        // of the signer key and return
                        // success.
                        self.index = self.certs.iter().position(|c| c.cert() == ka.cert());
                        assert!(self.index.is_some());
                    }
                }
                MessageLayer::Compression { .. } => {
                    unreachable!("we're verifying detached signatures")
                }
                MessageLayer::Encryption { .. } => {
                    unreachable!("we're verifying detached signatures")
                }
            }
        }

        Ok(())
    }
}
